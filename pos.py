# Version 0.010 - Enhanced with rich
# Updated with enhanced listing capabilities

# Standard library imports for core functionality
from dataclasses import dataclass, field  # For creating data classes with less boilerplate
from datetime import datetime  # For timestamp management
from enum import Enum  # For creating enumerated types
from typing import List, Dict  # For type hints
import json  # For data persistence
from pathlib import Path  # For cross-platform file handling
import cmd  # For building command-line interfaces

# Rich library imports for enhanced terminal UI
from rich.console import Console  # Main rich interface for terminal output
from rich.table import Table  # For creating formatted tables
from rich.panel import Panel  # For creating boxed content
from rich.prompt import Prompt  # For user input with formatting
from rich.tree import Tree  # For hierarchical display of items

# Enum definitions for work item categorization
class ItemType(Enum):
    """Defines the different types of work items that can be tracked"""
    TASK = "t"      # Regular tasks - day-to-day work items
    LEARNING = "l"  # Learning-related items - educational goals
    RESEARCH = "r"  # Research-related items - investigation tasks

class ItemStatus(Enum):
    """Defines the possible states of a work item"""
    NOT_STARTED = "not_started"   # New items start here
    IN_PROGRESS = "in_progress"   # Items currently being worked on
    COMPLETED = "completed"       # Finished items

class Priority(Enum):
    """Defines priority levels for work items"""
    LOW = 1    # Low urgency/importance
    MED = 2    # Medium urgency/importance
    HI = 3     # High urgency/importance - critical items

@dataclass
class WorkItem:
    """
    Core data structure representing a single work item.
    Uses @dataclass for automatic generation of __init__, __repr__, etc.
    
    Attributes:
        title: Short description of the item
        item_type: Category of the work item (TASK/LEARNING/RESEARCH)
        description: Detailed description of the work item
        goal: The broader goal this item belongs to
        priority: Importance level (LOW/MED/HI)
        status: Current state (NOT_STARTED/IN_PROGRESS/COMPLETED)
        id: Unique identifier (generated by WorkSystem)
        created_at: Timestamp of creation
        updated_at: Timestamp of last modification
    """
    title: str
    item_type: ItemType
    description: str
    goal: str
    priority: Priority = Priority.MED
    status: ItemStatus = ItemStatus.NOT_STARTED
    id: str = field(default="")  # Will be set by WorkSystem
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    
    def update_status(self, new_status: ItemStatus):
        self.status = new_status
        self.updated_at = datetime.now()

    def update_priority(self, new_priority: Priority):
        self.priority = new_priority
        self.updated_at = datetime.now()

    def to_dict(self) -> dict:
        return {
            'id': self.id,
            'title': self.title,
            'goal': self.goal,
            'item_type': self.item_type.value,
            'description': self.description,
            'priority': self.priority.value,
            'status': self.status.value,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }

class WorkSystem:
    """
    Core system for managing work items. Provides:
    - Persistent storage using JSON
    - Item creation and retrieval
    - Status and priority updates
    - Various sorting and filtering capabilities
    - Backup management during saves
    """
    def __init__(self, storage_path: str = "work_items.json"):
        """
        Initialize the work system
        Args:
            storage_path: Location of the JSON storage file
        """
        self.storage_path = Path(storage_path)
        self.items: Dict[str, WorkItem] = {}
        self.entry_counts: Dict[str, int] = {}  # Track entries per goal
        self.load_items()

    def generate_id(self, goal: str, item_type: ItemType, priority: Priority) -> str:
        """
        Creates a unique ID combining:
        - First letter of goal (g)
        - Type initial (t/l/r)
        - Priority number (1/2/3)
        - Sequential number for the goal
        - Current time
        
        Example: gt21230pm (goal-task-priority2-item1-2:30pm)
        """
        # Get first letter of goal and type
        goal_initial = goal[0].lower()
        type_initial = item_type.value[0].lower()
        
        # Get priority number
        priority_num = priority.value
        
        # Get entry count for this goal
        if goal not in self.entry_counts:
            self.entry_counts[goal] = 0
        self.entry_counts[goal] += 1
        entry_num = self.entry_counts[goal]
        
        # Get current time
        now = datetime.now()
        time_str = str(int(now.strftime("%I"))) + now.strftime("%M%p").lower()
        
        # Combine all parts
        return f"{goal_initial}{type_initial}{priority_num}{entry_num}{time_str}"

    def add_item(self, goal: str, title: str, item_type: ItemType,
                 description: str, priority: Priority = Priority.MED) -> WorkItem:
        try:
            item = WorkItem(
                title=title,
                goal=goal,
                item_type=item_type,
                description=description,
                priority=priority
            )
            # Generate and set the ID
            item.id = self.generate_id(goal, item_type, priority)
            self.items[item.id] = item
            self.save_items()
            return item
        except Exception as e:
            print(f"Error adding item: {e}")
            raise

    def get_items_by_goal(self, goal: str) -> List[WorkItem]:
        """
        Retrieves items for a specific goal, sorted by:
        1. Priority (highest first)
        2. Creation time (newest first)
        """
        return sorted(
            [item for item in self.items.values() if item.goal.lower() == goal.lower()],
            key=lambda x: (x.priority.value, x.created_at),
            reverse=True
        )

    def get_items_by_goal_priority(self, goal: str) -> List[WorkItem]:
        """
        Retrieves items for a goal, sorted only by priority.
        Useful for priority-focused views.
        """
        return sorted(
            [item for item in self.items.values() if item.goal.lower() == goal.lower()],
            key=lambda x: (x.priority.value),
            reverse=True
        )

    def get_items_by_goal_id(self, goal: str) -> List[WorkItem]:
        """Get items for a goal, sorted by creation time (newest first)"""
        return sorted(
            [item for item in self.items.values() if item.goal.lower() == goal.lower()],
            key=lambda x: x.created_at,
            reverse=True
        )

    def get_incomplete_items(self) -> List[WorkItem]:
        """Get all incomplete items across all goals, sorted by priority"""
        return sorted(
            [item for item in self.items.values() 
             if item.status != ItemStatus.COMPLETED],
            key=lambda x: (x.priority.value, x.created_at),
            reverse=True
        )

    def get_items_by_type(self, item_type: ItemType) -> List[WorkItem]:
        return sorted(
            [item for item in self.items.values() if item.item_type == item_type],
            key=lambda x: (x.priority.value, x.created_at),
            reverse=True
        )

    def get_all_goals(self) -> List[str]:
        return sorted(list(set(item.goal for item in self.items.values())))

    def update_item_status(self, item_id: str, new_status: ItemStatus):
        """
        Updates an item's status and ensures it's properly saved
        Args:
            item_id: The ID of the item to update
            new_status: The new status to set
        """
        try:
            if item_id in self.items:
                item = self.items[item_id]
                old_status = item.status
                item.update_status(new_status)
                self.save_items()
                # Add verification
                if self.items[item_id].status != new_status:
                    print(f"[bold red]Warning: Status update failed. Expected {new_status.value}, got {self.items[item_id].status.value}[/bold red]")
                else:
                    print(f"[bold green]Status updated from {old_status.value} to {new_status.value}[/bold green]")
            else:
                print(f"[bold red]Item {item_id} not found[/bold red]")
        except Exception as e:
            print(f"[bold red]Error updating status: {e}[/bold red]")
            raise

    def update_item_priority(self, item_id: str, new_priority: Priority):
        try:
            if item_id in self.items:
                self.items[item_id].update_priority(new_priority)
                self.save_items()
            else:
                print(f"Item {item_id} not found")
        except Exception as e:
            print(f"Error updating priority: {e}")
            raise

    def save_items(self):
        try:
            items_dict = {id_: item.to_dict() for id_, item in self.items.items()}
            # Also save entry counts
            data = {
                'items': items_dict,
                'entry_counts': self.entry_counts
            }
            
            if self.storage_path.exists():
                backup_path = self.storage_path.with_suffix('.json.bak')
                self.storage_path.rename(backup_path)
            
            with open(self.storage_path, 'w') as f:
                json.dump(data, f, indent=2)
            
            if Path(str(self.storage_path) + '.bak').exists():
                Path(str(self.storage_path) + '.bak').unlink()
                
        except Exception as e:
            print(f"Error saving items: {e}")
            if Path(str(self.storage_path) + '.bak').exists():
                Path(str(self.storage_path) + '.bak').rename(self.storage_path)
            raise

    def load_items(self):
        if not self.storage_path.exists():
            return
        
        with open(self.storage_path, 'r') as f:
            data = json.load(f)
            
        # Handle both old and new format
        if isinstance(data, dict) and 'items' in data:
            items_dict = data['items']
            self.entry_counts = data.get('entry_counts', {})
        else:
            items_dict = data
            # Reconstruct entry counts from existing items
            self.entry_counts = {}
            
        for _, item_data in items_dict.items():
            # Handle legacy data without 'goal' field
            goal = item_data.get('goal', 'legacy')
            
            item = WorkItem(
                title=item_data['title'],
                goal=goal,
                item_type=ItemType(item_data['item_type']),
                description=item_data['description'],
                priority=Priority(item_data['priority']),
                status=ItemStatus(item_data['status']),
                id=item_data['id'],
                created_at=datetime.fromisoformat(item_data['created_at']),
                updated_at=datetime.fromisoformat(item_data['updated_at'])
            )
            self.items[item.id] = item
            
            # Update entry counts based on existing items
            if goal not in self.entry_counts:
                self.entry_counts[goal] = 0
            self.entry_counts[goal] = max(self.entry_counts[goal], 
                int(''.join(filter(str.isdigit, item.id[:4])) or 0))

    def export_markdown(self, output_path: str = "work_items.md"):
        with open(output_path, 'w') as f:
            f.write("# Work Items\n\n")
            
            goals = self.get_all_goals()
            for goal in goals:
                f.write(f"## Goal: {goal}\n\n")
                goal_items = self.get_items_by_goal(goal)
                
                for item_type in ItemType:
                    type_items = [item for item in goal_items if item.item_type == item_type]
                    if not type_items:
                        continue
                        
                    f.write(f"### {item_type.value.title()}\n\n")
                    
                    for priority in reversed(list(Priority)):
                        priority_items = [item for item in type_items if item.priority == priority]
                        if not priority_items:
                            continue
                            
                        f.write(f"#### {priority.name.title()} Priority\n\n")
                        
                        for item in priority_items:
                            f.write(f"##### {item.title}\n")
                            f.write(f"- **ID**: {item.id}\n")
                            f.write(f"- **Status**: {item.status.value}\n")
                            f.write(f"- **Created**: {item.created_at.strftime('%Y-%m-%d %H:%M')}\n")
                            f.write(f"- **Description**: {item.description}\n\n")

class WorkSystemCLI(cmd.Cmd):
    """
    Command-line interface providing:
    - Interactive command prompt
    - Rich text formatting for output
    - Command history
    - Help system
    
    Commands:
    - add: Create new items
    - list: View items with various filters
    - update: Modify existing items
    - export: Generate markdown report
    - quit: Exit the program
    """
    intro = "[bold green]Welcome to the Work System CLI![/bold green] Type help or ? to list commands.\n"
    prompt = "(work) "

    def __init__(self):
        super().__init__()
        self.work_system = WorkSystem()
        self.console = Console()

    def print_items(self, items: List[WorkItem]):
        """
        Creates a formatted table showing:
        - Item ID
        - Title
        - Type
        - Priority
        - Status
        - Creation date
        - Description
        
        Uses rich library for enhanced formatting with color-coded priority and status:
        - Priority: HI=bright_red, MED=yellow, LOW=green
        - Status: completed=green, in_progress=yellow, not_started=red
        """
        if not items:
            self.console.print("[bold yellow]No items to display.[/bold yellow]")
            return

        table = Table(show_header=True, header_style="bold magenta")
        table.add_column("ID", style="cyan", no_wrap=True)
        table.add_column("Title", style="green")
        table.add_column("Type", style="yellow")
        table.add_column("Priority", justify="center")
        table.add_column("Status", justify="center")
        table.add_column("Created", style="white")
        table.add_column("Description", style="white")
        
        for item in items:
            # Set priority color
            priority_color = {
                Priority.HI: "bright_red",
                Priority.MED: "yellow",
                Priority.LOW: "green"
            }.get(item.priority, "white")
            
            # Set status color
            status_color = {
                ItemStatus.COMPLETED: "green",
                ItemStatus.IN_PROGRESS: "yellow",
                ItemStatus.NOT_STARTED: "red"
            }.get(item.status, "white")
            
            table.add_row(
                item.id,
                item.title,
                item.item_type.value,
                f"[{priority_color}]{item.priority.name}[/{priority_color}]",
                f"[{status_color}]{item.status.value}[/{status_color}]",
                item.created_at.strftime('%Y-%m-%d %H:%M'),
                item.description
            )
        self.console.print(table)

    def do_add(self, arg):
        """
        Adds new work items. Example usage:
        add ProjectA-t-HI-Setup Database-Create initial schema
        
        Format:
        add <goal>-<type>-<priority>-<title>-<description>
        """
        try:
            parts = arg.split('-', 4)
            if len(parts) < 5:
                self.console.print("[bold red]Error:[/bold red] Not enough parts. Format: goal-type-priority-title-description")
                return

            goal, type_, priority, title, description = parts
            
            item = self.work_system.add_item(
                goal=goal.strip(),
                item_type=ItemType(type_.strip()),
                priority=Priority[priority.strip().upper()],
                title=title.strip(),
                description=description.strip()
            )
            self.console.print(f"[bold green]Added:[/bold green] {item.title} (ID: {item.id})")
        except Exception as e:
            self.console.print(f"[bold red]Error:[/bold red] {e}")

    def do_list(self, arg):
        """
        Lists items with various filters. Examples:
        - list ProjectA          (all items for goal)
        - list ProjectA priority (sorted by priority)
        - list ProjectA id       (sorted by creation)
        - list incomplete        (all incomplete items)
        - list all              (everything)
        """
        args = arg.lower().strip().split()
        
        try:
            # Handle empty argument
            if not args:
                self.console.print("[bold yellow]Please specify what to list.[/bold yellow] Type 'help list' for options.")
                return

            # Handle 'list incomplete'
            if args[0] == 'incomplete':
                self.console.rule("[bold red]INCOMPLETE ITEMS (All Goals, By Priority)[/bold red]")
                items = self.work_system.get_incomplete_items()
                self.print_items(items)
                return

            # Handle 'list all'
            if args[0] == 'all':
                goals = self.work_system.get_all_goals()
                for goal in goals:
                    self.console.rule(f"[bold blue]GOAL: {goal.upper()}[/bold blue]")
                    items = self.work_system.get_items_by_goal(goal)
                    self.print_items(items)
                return

            # Handle goal-specific listings
            goal = args[0]
            
            # Handle 'list <goal> priority'
            if len(args) > 1 and args[1] == 'priority':
                self.console.rule(f"[bold blue]GOAL: {goal.upper()} (By Priority)[/bold blue]")
                items = self.work_system.get_items_by_goal_priority(goal)
                self.print_items(items)
                return

            # Handle 'list <goal> id'
            if len(args) > 1 and args[1] == 'id':
                self.console.rule(f"[bold blue]GOAL: {goal.upper()} (By Creation Time)[/bold blue]")
                items = self.work_system.get_items_by_goal_id(goal)
                self.print_items(items)
                return

            # Default: list all items for the goal
            items = self.work_system.get_items_by_goal(goal)
            if items:
                self.console.rule(f"[bold blue]GOAL: {goal.upper()}[/bold blue]")
                self.print_items(items)
            else:
                self.console.print(f"[bold yellow]No items found for goal:[/bold yellow] {goal}")

        except Exception as e:
            self.console.print(f"[bold red]Error:[/bold red] {e}")

    def do_update(self, arg):
        """
        Handles status updates for existing items.
        Simple format: update-<id>-<new_status>
        Extended format: update-<id>-<status|priority>-<new_value>
        """
        try:
            parts = arg.split('-')
            
            # Handle simple status update format (update-id-status)
            if len(parts) == 3:
                item_id, new_status = parts[1:]
                self.work_system.update_item_status(item_id.strip(), ItemStatus(new_status.strip()))
                self.console.print(f"[bold green]Updated item[/bold green] {item_id}")
                return
            
            # Handle extended format (update-id-field-value)
            if len(parts) == 4:
                item_id, field, value = parts[1:]
                if field.strip() == 'status':
                    self.work_system.update_item_status(item_id.strip(), ItemStatus(value.strip()))
                elif field.strip() == 'priority':
                    self.work_system.update_item_priority(item_id.strip(), Priority[value.strip().upper()])
                self.console.print(f"[bold green]Updated item[/bold green] {item_id}")
                return
                
            self.console.print("[bold red]Error:[/bold red] Format should be: update-id-status or update-id-field-value")
            
        except Exception as e:
            self.console.print(f"[bold red]Error:[/bold red] {e}")

    def do_export(self, arg):
        """
        Exports work items to a markdown file for external viewing.
        Organizes items by goal, type, and priority.
        """
        filename = arg.strip() if arg.strip() else "work_items.md"
        try:
            self.work_system.export_markdown(filename)
            self.console.print(f"[bold green]Successfully exported to[/bold green] {filename}")
        except Exception as e:
            self.console.print(f"[bold red]Error exporting to markdown:[/bold red] {e}")

    def do_quit(self, arg):
        """Quit the program"""
        self.console.print("[bold magenta]Goodbye![/bold magenta]")
        return True

    def do_tree(self, arg):
        """
        Display a hierarchical tree view of goals and their work items.
        Shows items organized by goal with color-coded status and priority.
        """
        tree = Tree("[bold magenta]Work System Overview[/bold magenta]")
        goals = self.work_system.get_all_goals()
        
        if not goals:
            self.console.print("[bold yellow]No goals/items to display.[/bold yellow]")
            return
        
        for goal in goals:
            goal_branch = tree.add(f"[bold blue]{goal.upper()}[/bold blue]")
            items = self.work_system.get_items_by_goal(goal)
            
            # Group items by type
            for item_type in ItemType:
                type_items = [item for item in items if item.item_type == item_type]
                if not type_items:
                    continue
                    
                type_branch = goal_branch.add(f"[bold yellow]{item_type.name}[/bold yellow]")
                
                # Group by priority
                for priority in reversed(list(Priority)):
                    priority_items = [item for item in type_items if item.priority == priority]
                    if not priority_items:
                        continue
                        
                    # Use our existing color scheme for priority
                    priority_color = {
                        Priority.HI: "bright_red",
                        Priority.MED: "yellow",
                        Priority.LOW: "green"
                    }.get(priority, "white")
                    
                    priority_branch = type_branch.add(f"[{priority_color}]{priority.name} Priority[/{priority_color}]")
                    
                    for item in priority_items:
                        # Use our existing color scheme for status
                        status_color = {
                            ItemStatus.COMPLETED: "green",
                            ItemStatus.IN_PROGRESS: "yellow",
                            ItemStatus.NOT_STARTED: "red"
                        }.get(item.status, "white")
                        
                        priority_branch.add(
                            f"[cyan]{item.id}[/cyan] - {item.title} "
                            f"([{status_color}]{item.status.value}[/{status_color}])"
                        )
        
        self.console.print(tree)

# Entry point for the CLI application
if __name__ == '__main__':
    WorkSystemCLI().cmdloop()
